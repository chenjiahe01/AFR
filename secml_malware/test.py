import os
import magic
# import secml_malware
from secml.array import CArray

from secml_malware.attack.whitebox import CKreukEvasion
from secml_malware.attack.whitebox import CFastGradientSignMethodEvasion
from secml_malware.attack.whitebox import CPaddingEvasion
from secml_malware.models.malconv import MalConv
from secml_malware.models.c_classifier_end2end_malware import CClassifierEnd2EndMalware, End2EndModel
from secml_malware.attack.whitebox.c_header_evasion import CHeaderEvasion
from secml_malware.attack.whitebox.c_discretized_bytes_evasion import  CDiscreteBytesEvasion
from secml_malware.attack.whitebox.c_extend_dos_evasion import CExtendDOSEvasion


#input_shape=(1, 2 ** 20 = 1048576)

def sys_sample(bytefile):
    result = []
    for i in range(0, len(bytefile), 10000):
        result.append(int(bytefile[i]))
    return result

write_adfile_path = './ad_sample/'

net1 = MalConv()
print('net_MalConv', net1)
net = CClassifierEnd2EndMalware(net1)
# print('CClassifierEnd2EndMalware', net)
net.load_pretrained_model()
print('models loaded...')
# print('net', net)
folder = "./data/malware_samples/test_folder/"
X = []
y = []
file_names = []
for i, f in enumerate(os.listdir(folder)):
    path = os.path.join(folder, f)
    # if 'petya' not in path:
    #     print('petya not in the path:', path)
    #     continue
    # if "PE32" not in magic.from_file(path):
    #     print('PE32 not in the path:', path)
    #     continue
    with open(path, "rb") as file_handle:
        code = file_handle.read()
    # print('code_len',len(code) )
    #data transform
    x = End2EndModel.bytes_to_numpy(
        code, net.get_input_max_length(), 256, False
    )
    _, confidence = net.predict(CArray(x), True)
    # print('conf:', confidence)

    if confidence[0, 1].item() < 0.5:
        continue
    # print('loop executed')
    print(f"> Added {f} with confidence {confidence[0,1].item()}")
    X.append(x)
    conf = confidence[1][0].item()
    y.append([1 - conf, conf])
    file_names.append(path)
print(len(X), 'files loaded...')
# print('X', X, 'y', y)



# fgsm, one dementional bug in calculating loss
# fgsm = CKreukEvasion(net, how_many_padding_bytes=512, epsilon=0.1, iterations=100)
# print('fgsm started')
# for sample, label in zip(X, y):
#     print('label[1]',label[1])
#     y_pred, adv_score, adv_ds, f_obj = fgsm.run(CArray(sample), CArray(label[1]))
#     print('partial_dos:',partial_dos.confidences_)
#     print('f_obj:',f_obj)
# print('fgsm attack executed...')


#Padding attack, 
# model init data format 
		# end2end_model : CClassifierEnd2EndMalware
		# 	the target end-to-end model
		# how_many : int
		# 	how many padding byte to inject
		# iterations : int, optional, default 100
		# 	the number of iterations of the optimizer
		# is_debug : bool, optional, default False
		# 	if True, prints debug information during the optimization
		# random_init : bool, optional, default False
		# 	if True, it randomizes the locations set by index_to_perturb before starting the optimization
		# threshold : float, optional, default 0
		# 	the detection threshold to bypass. Default is 0
		# penalty_regularizer : float, optional, default 0
		# 	the reularization parameter, Default is 0
padding_model = CPaddingEvasion(net, how_many=512, iterations=100, is_debug=False, random_init=False, threshold=0, penalty_regularizer=0)
print('padding started')
for sample, label in zip(X, y):
    print('label[1]',label[1])
    y_pred, adv_score, adv_ds, f_obj = padding_model.run(CArray(sample), CArray(label[1]))
    print('y_pred:', y_pred, 'adv_score', adv_score)
    print('adv_ds', adv_ds)
    print('f_obj:', f_obj)
print('padding_model attack executed...')








# Paticial Dos Header, done
# partial_dos = CHeaderEvasion(net, random_init=False, iterations=50, optimize_all_dos=False, threshold=0.5)
# print('partial_dos', partial_dos)
# i = 0
# for sample, label in zip(X, y):
#     curr_filename = file_names[i].split('/')[-1]
#     y_pred, adv_score, adv_ds, f_obj = partial_dos.run(CArray(sample), CArray(label[1]))
#     print('partial_dos.confidences_', partial_dos.confidences_)
#     print('attack executed...')

#     adv_x = adv_ds.X[0,:]
#     # print('adv_x', adv_x)

#     real_adv_x = partial_dos.create_real_sample_from_adv(file_names[i], adv_x, write_adfile_path+curr_filename)
#     # print('len(real_adv_x):', len(real_adv_x))
#     real_x = End2EndModel.bytes_to_numpy(real_adv_x, net.get_input_max_length(), 256, False)
#     _, confidence = net.predict(CArray(real_x), True)
#     print('confidence[0,1].item()', confidence[0,1].item())
#     i+=1



# fgsm = CFastGradientSignMethodEvasion(net, how_many_padding_bytes=1024, epsilon=0.1, iterations=100)
# print('fgsm started')
# for sample, label in zip(X, y):
#     print('label[1]',label[1])
#     y_pred, adv_score, adv_ds, f_obj = fgsm.run(CArray(sample), CArray(label[1]))
#     print('partial_dos:',partial_dos.confidences_)
#     print('f_obj:',f_obj)
# print('attack executed...')



print('we\'re done...')